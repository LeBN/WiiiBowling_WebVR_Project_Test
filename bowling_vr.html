<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>VR Bowling — Prototype (One-File)</title>

  <!-- A-Frame + extras + physics (pas de super-hands) -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#0e1116;color:#fff}
    .hud{position:fixed;left:12px;top:12px;background:#0009;padding:10px 12px;border-radius:12px;z-index:5;line-height:1.35;max-width:420px}
    .panel{position:fixed;right:12px;top:12px;background:#0009;padding:10px 12px;border-radius:12px;z-index:6;min-width:260px}
    .panel h3{margin:0 0 6px 0;font-weight:700}
    .panel .row{display:flex;gap:6px;flex-wrap:wrap}
    .panel button{background:#2b6cb0;color:#fff;border:0;border-radius:10px;padding:6px 10px;cursor:pointer}
    .panel button:disabled{opacity:.6;cursor:not-allowed}
    .panel .chip{padding:6px 10px;border-radius:999px;background:#1f2937;cursor:pointer;border:1px solid #334155}
    .panel .chip.active{background:#0ea5e9;border-color:#0284c7}
    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:#111c;padding:8px 12px;border-radius:10px;border:1px solid #2b3340;z-index:10;display:none}
    .toast.show{display:block}
  </style>
  
  <script>
    // ---------- Son et musiques ----------
    window.addEventListener('enter-vr', () => {
      const loopSound = document.querySelector('#sndLoop');
      
      loopSound.addEventListener('loadeddata', () => {
        const scene = document.querySelector('a-scene');
        
        const ambient = document.createElement('a-entity');
        ambient.setAttribute('sound', 'src:#sndLoop; loop:true; positional:false; volume:0.4; autoplay:true');
        scene.appendChild(ambient);
      });
    });

    // ---------- Déplacements stick gauche ----------
    AFRAME.registerComponent('left-stick-move', {
      schema:{rig:{type:'selector'}, speed:{default:2.1}, dead:{default:0.18}},
      init(){
        this.vx=0; this.vy=0;
        this.onThumb = e=>{
          const x=e.detail.x||0, y=e.detail.y||0;
          this.vx = (Math.abs(x)>this.data.dead)? x : 0;
          this.vy = (Math.abs(y)>this.data.dead)? y : 0;
        };
        this.el.addEventListener('thumbstickmoved', this.onThumb);
        
      },

      
      tick(t,dt){
        const rigEl=this.data.rig; if(!rigEl) return;
        if(!this.vx && !this.vy) return;
        const rig=rigEl.object3D;
        const yaw = THREE.MathUtils.degToRad(rigEl.getAttribute('rotation').y);
        const cos=Math.cos(yaw), sin=Math.sin(yaw);
        const forward=this.vy, strafe=this.vx;
        const step=this.data.speed*(dt/1000);
        rig.position.x += (strafe*cos + forward*sin)*step;
        rig.position.z += (forward*cos - strafe*sin)*step;
      },
      remove(){ this.el.removeEventListener('thumbstickmoved', this.onThumb); }
    });

    // ---------- Rotation stick droit ----------
    AFRAME.registerComponent('right-stick-smoothturn', {
      schema:{rig:{type:'selector'}, speedDeg:{default:140}, dead:{default:0.18}},
      init(){ this.x=0; this.el.addEventListener('thumbstickmoved', e=>{
        const x=e.detail.x||0; this.x=(Math.abs(x)>this.data.dead)?x:0;
      });},
      tick(t,dt){ const r=this.data.rig; if(!r||!this.x) return;
        const rot=r.getAttribute('rotation'); rot.y -= this.x*this.data.speedDeg*(dt/1000);
        r.setAttribute('rotation',rot);
      }
    });

    // ---------- Ray-based grab (sans super-hands) ----------
AFRAME.registerComponent('ray-grab', {
  schema:{
    objects:{default:'.grab-target'},
    throwScale:{type: "vec3", default: {x: 3, y:3, z: 5}} // ajuste si tu veux plus/moins de puissance globale
  },
  init(){
    this.grabbed=null;
    this.lastPos=new THREE.Vector3();
    this.prevPos=new THREE.Vector3();
    this.tmp=new THREE.Vector3();

    // Saisir / relâcher (casque + émulateur)
    const down = this._onDown.bind(this), up = this._onUp.bind(this);
    this.el.addEventListener('gripdown', down);
    this.el.addEventListener('gripup',   up);
    this.el.addEventListener('squeezestart', down);
    this.el.addEventListener('squeezeend',   up);
    this.el.addEventListener('triggerdown',  down);
    this.el.addEventListener('triggerup',    up);
  },
  tick(){
    this.prevPos.copy(this.lastPos);
    this.el.object3D.getWorldPosition(this.lastPos);
  },
  _pick(){
    const r=this.el.components.raycaster;
    const list = r && (r.intersections || (r.getIntersections&&r.getIntersections()));
    if(!list||!list.length) return null;
    for(const hit of list){
      const el = hit.object && hit.object.el;
      if(el && el.classList && el.classList.contains('grab-target')) return el;
    }
    return null;
  },
  _onDown(){
    if(this.grabbed) return;
    const target=this._pick(); if(!target) return;
    if(!this.el.id) this.el.setAttribute('id','hand-'+Math.random().toString(36).slice(2,7));
    if(!target.hasAttribute('dynamic-body')) target.setAttribute('dynamic-body','mass:5');
    target.setAttribute('constraint',`type:lock; target:#${this.el.id}`);
    target.classList.add('held');
    this.grabbed=target;
  },
  _onUp(){
    if(!this.grabbed) return;
    const scene=this.el.sceneEl;
    const ent=this.grabbed;

    // libère la contrainte
    ent.removeAttribute('constraint');

    if(ent.body){
      // Vitesse = déplacement de la main / dt, multiplié par throwScale (aucun clamp/assist)
      const dt = Math.max((scene.timeDelta||16.7)/1000, 0.001); // sécu pour ne pas diviser par 0
      const v = this.tmp.subVectors(this.lastPos, this.prevPos).divideScalar(dt).multiply(this.data.throwScale);

      // Applique la vélocité
      ent.body.velocity.set(v.x, v.y, v.z);

      // Spin  : ω = (up × v_horiz) / r
      const up = new THREE.Vector3(0,1,0);
      const vh = new THREE.Vector3(v.x, 0, v.z);
      const r  = ent.getAttribute('radius') || 0.12;
      const omega = new THREE.Vector3().copy(up).cross(vh).multiplyScalar(1/Math.max(r,0.001));
      ent.body.angularVelocity.set(omega.x, omega.y, omega.z);

      try{
        const wp = ent.object3D.getWorldPosition(new THREE.Vector3());
        playAt(scene,'sndThrow',wp);
      }catch(e){}
    }

    ent.classList.remove('held');
    this.grabbed=null;
  }
});


    // ---------- Utilitaire son 3D ----------
    function playAt(scene, id, pos){
      const s = document.createElement('a-entity');
      s.setAttribute('position', pos.x+' '+pos.y+' '+pos.z);
      s.setAttribute('sound', 'src:#'+id+'; autoplay:true; positional:true; volume:0.9; refDistance:1.8; rolloffFactor:1.0');
      scene.appendChild(s);
      setTimeout(()=> s.remove(), 1200);
    }

    // ---------- Jeu ----------
    const DIFFS = {
      easy:   { ballDampLin: 0.14, ballDampAng: 0.35, gutterHalf: 1, wobble: 0.00 },
      normal: { ballDampLin: 0.08, ballDampAng: 0.20, gutterHalf: 1.5, wobble: 0.03 },
      hard:   { ballDampLin: 0.03, ballDampAng: 0.08, gutterHalf: 1.8, wobble: 0.08 }
    };
    const BALLS = [
      {name:'Légère',  radius:0.15, mass:3.0,  color:'blue'}, // #479aa5
      {name:'Standard',radius:0.22, mass:5.0,  color:'green'}, // #32CD32
      {name:'Lourde',  radius:0.28, mass:7.25, color:'pink'} // #f79ac5
    ];

    AFRAME.registerComponent('bowling-game', {
      schema:{
        difficulty:{default:'normal'},
        laneLength:{default:38.45},
        laneWidth:{default:2.12},
        foulZ:{default:0.0},
        pinZ:{default:-36.6},
        playersCount:{default:4}
      },
      init(){
        this.throws=0; this.scoreThisFrame=0; this.inPlay=false;
        this.downSet = new Set();
        this._pins=[]; this._ball=null;

        this._ui();
        this._buildLane();
        this.resetFrame();
        this._scoreboardInit();
        this._initMatch(this._defaultNames(this.data.playersCount));

        // Hauteur VR : 
        const scene = this.el.sceneEl;
        const rig = document.getElementById('rig');
        const baseZ = rig ? rig.getAttribute('position').z : 2.8;
        if (scene && rig){
          scene.addEventListener('enter-vr', ()=>{
            const p=rig.getAttribute('position');
            rig.setAttribute('position',{x:p.x,y:0,z:baseZ});
            this._toast('⚠️ Grip pour saisir, relâche pour lancer. Vise la ligne rouge.');
          });
          scene.addEventListener('exit-vr', ()=>{
            const p=rig.getAttribute('position');
            rig.setAttribute('position',{x:p.x,y:1.6,z:baseZ});
          });
        }
        // --- Test lancer pour test en non vr avec le bouton Y du contrôleur GAUCHE ---
        const leftCtl = document.getElementById('leftCtl');
        if (leftCtl){
          this._onYDown = () => this._buttonThrowFrom(leftCtl, 6.8); // 6.8 = vitesse;
          leftCtl.addEventListener('ybuttondown', this._onYDown);
        }
      },
      _defaultNames(n){
        n = Math.max(1, Math.min(4, n|0));
        const arr = [];
        for (let i = 1; i <= n; i++) arr.push('J' + i);
        return arr;
      },

      // -------- UI & helpers --------
      _ui(){
        this._scoreEl = document.getElementById('score');
        this._statusEl = document.getElementById('status');

        const chips = document.querySelectorAll('.chip[data-diff]');
        chips.forEach(ch=>{
          ch.addEventListener('click', ()=>{
            chips.forEach(x=>x.classList.remove('active'));
            ch.classList.add('active');
            this.data.difficulty = ch.dataset.diff;
            this._applyDifficulty();
          });
        });
        document.querySelector(`.chip[data-diff="${this.data.difficulty}"]`)?.classList.add('active');

        document.querySelectorAll('[data-ball]').forEach((btn,i)=>{
          btn.addEventListener('click', ()=> this.spawnBall(i,true));
        });
        document.getElementById('resetAll').addEventListener('click', ()=> this.resetFrame(true));

        // ----- Sélecteur du nombre de joueurs -----
        const pchips = document.querySelectorAll('.playerCount');
        const applyPlayers = (n)=>{
          this.data.playersCount = n;
          // (ré)initialise J1..Jn
          this._initMatch(this._defaultNames(n));
          this.resetFrame(true); // quilles + boule + écrans
          // visuel
          pchips.forEach(c=>c.classList.remove('active'));
          document.querySelector(`.playerCount[data-players="${n}"]`)?.classList.add('active');
          this._toast(`Match configuré pour ${n} joueur${n>1?'s':''}.`);
        };
        // clics sur 1/2/3/4
        pchips.forEach(ch=>{
          ch.addEventListener('click', ()=> applyPlayers(+ch.dataset.players));
        });
        // surligne le joueur correspondant
        document.querySelector(`.playerCount[data-players="${this.data.playersCount}"]`)?.classList.add('active');
      },
      
      _setStatus(t){
        if (this._statusEl) this._statusEl.textContent = t;
        this._renderScoreboard();
      },
      _setScore(){
        if (this._scoreEl)
          this._scoreEl.textContent = `Lancers: ${this.throws}/2 • Quilles tombées: ${this.downSet.size} • Score frame: ${this.scoreThisFrame}`;
        this._renderScoreboard();
      },

      _toast(t){ const el=document.getElementById('toast'); el.textContent=t; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'), 1500); },



      _buttonThrowFrom(ctrlEl, speed = 6.8){
      // 1) (re)crée une boule standard
      this.spawnBall(1, false);
      const b = this._ball;
      const scene = this.el.sceneEl;

      // 2) direction = avant du contrôleur
      const o3d = ctrlEl.object3D;
      const q = new THREE.Quaternion(), pos = new THREE.Vector3();
      o3d.getWorldQuaternion(q);
      o3d.getWorldPosition(pos);

      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(q);
      dir.y = 0; if (dir.lengthSq() < 1e-6) dir.set(0,0,-1);
      dir.normalize();

      // départ:
      const start = pos.clone().add(dir.clone().multiplyScalar(0.4));
      start.y = 0.18;
      b.setAttribute('position', `${start.x} ${start.y} ${start.z}`);

      // 3) applique la vélocité
      const apply = ()=>{
        const v = dir.clone().multiplyScalar(speed);
        b.body.velocity.set(v.x, v.y, v.z);

        const up = new THREE.Vector3(0,1,0);
        const vh = new THREE.Vector3(v.x,0,v.z);
        const r  = b.getAttribute('radius') || 0.12;
        const omega = up.clone().cross(vh).multiplyScalar(1/Math.max(r,0.001));
        b.body.angularVelocity.set(omega.x, omega.y, omega.z);

        try{
          const wp = b.object3D.getWorldPosition(new THREE.Vector3());
          playAt(scene,'sndThrow',wp);
        }catch(_){}
      };
      if (b.body) apply(); else b.addEventListener('body-loaded', apply);
    },




      // --- ÉCRAN: canvas + références ---
      _scoreboardInit(){
        this._scoreCanvas = document.getElementById('scoreCanvas');
        this._sbPlane = document.getElementById('scoreboardPlane');
        this._sbCtx = this._scoreCanvas && this._scoreCanvas.getContext('2d');
        this._lastDownCount = -1;
        this._renderScoreboard();
      },

      // --- ÉCRAN: rendu (statut + schéma des 10 quilles) ---
      _renderScoreboard(){
        const c = this._scoreCanvas, ctx = this._sbCtx;
        if (!c || !ctx) return;

        const W = c.width, H = c.height;
        // fond
        ctx.clearRect(0,0,W,H);
        const g = ctx.createLinearGradient(0,0,0,H);
        g.addColorStop(0,'#0b1118'); g.addColorStop(1,'#0e1622');
        ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

        // titre + infos
        ctx.fillStyle='#9bdcff'; ctx.font='bold 42px system-ui,Segoe UI,Roboto';
        ctx.fillText('VR BOWLING', 36, 64);
        ctx.fillStyle='#cbd5e1'; ctx.font='24px system-ui,Segoe UI,Roboto';
        ctx.fillText(`Difficulte : ${this.data.difficulty}`, 36, 108);

        // statut + score
        const scoreLine = `Lancers: ${this.throws}/2   •   Quilles tombées: ${this.downSet.size}   •   Score frame: ${this.scoreThisFrame}`;
        ctx.fillStyle='#a7f3d0'; ctx.font='28px system-ui,Segoe UI,Roboto';
        ctx.fillText(scoreLine, 36, 190);

        // schéma des 10 quilles (1 devant, 2 au milieu-devant, 3 milieu-fond et 4 au fond)
        const fallen = new Set(Array.from(this.downSet).map(p => +p.dataset.pinIndex || 0));
        const layout = [
          [{x:0,y:0}],
          [{x:-1,y:1},{x:1,y:1}],
          [{x:-2,y:2},{x:0,y:2},{x:2,y:2}],
          [{x:-3,y:3},{x:-1,y:3},{x:1,y:3},{x:3,y:3}]
        ].flat();

        const cx = W - 260;   // position horizontale
        const cy = 280;       // position verticale
        const S  = 42;        // espacement entre rangées
        ctx.fillStyle='#cbd5e1'; ctx.font='22px system-ui,Segoe UI,Roboto';
        ctx.fillText('Quilles', cx - 36, cy - 110);

        layout.forEach((p,i)=>{
          const xi = cx + p.x*S, yi = cy + p.y*S, idx = i+1;
          const isDown = fallen.has(idx);
          ctx.beginPath(); ctx.arc(xi, yi, 16, 0, Math.PI*2);
          ctx.fillStyle = isDown ? '#64748b' : '#ffffff'; ctx.fill();
          ctx.lineWidth=3; ctx.strokeStyle = isDown ? '#475569' : '#94a3b8'; ctx.stroke();
          ctx.fillStyle = isDown ? '#94a3b8' : '#0b1118';
          ctx.font='bold 16px system-ui,Segoe UI,Roboto';
          const txt = String(idx), w = ctx.measureText(txt).width;
          ctx.fillText(txt, xi - w/2, yi + 6);
        });

        // rafraîchir la texture sur le <a-plane>
        try{
          const mat = this._sbPlane?.components?.material?.material;
          if (mat && mat.map) mat.map.needsUpdate = true;
        }catch(e){}

      const mesh = this._sbPlane && this._sbPlane.getObject3D('mesh');
      if (mesh && mesh.material && mesh.material.map) {
        mesh.material.map.needsUpdate = true;
        }
      },




      /* ===================== SCOREBOARD (4 joueurs / 10 frames) ===================== */

        // -- Initialisation du match (4 joueurs par défaut) --
        _initMatch(names = ['J1','J2','J3','J4']){
          this.players = names.map(n => ({
            name:n,
            frames: new Array(10).fill(0).map(()=>({rolls:[], score:null, cum:null}))
          }));
          this.currP = 0;     // joueur courant (0..3)
          this.currF = 0;     // frame courante (0..9)
          this.currRoll = 0;  // lancer dans la frame (0,1,2 au 10e)
          // canvases
          this._mainCanvas = document.getElementById('scoreMain');
          this._mainCtx    = this._mainCanvas?.getContext('2d');
          this._mainPlane  = document.getElementById('mainBoardPlane');
          this._renderMainBoard();
        },

        // -- Rendu du tableau des scores --
        _renderMainBoard(){
          const c=this._mainCanvas, ctx=this._mainCtx; if(!c||!ctx) return;
          const W=c.width, H=c.height;
          // fond
          ctx.clearRect(0,0,W,H);
          const g=ctx.createLinearGradient(0,0,0,H);
          g.addColorStop(0,'#0b1118'); g.addColorStop(1,'#0e1622');
          ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

          // titre
          ctx.fillStyle='#9bdcff'; ctx.font='bold 56px system-ui,Segoe UI,Roboto';
          ctx.fillText('SCORES', 36, 70);

          // grille (10 frames + total)
          const left   = 260;
          const top    = 120;
          const nameW  = 220;
          const cellW  = 140;
          const totalW = 180;

          const MAX_ROWS = 4; //max 4 joueurs
          const bottomGap = 24; // marge visuelle en bas
          const rowH = Math.floor((H - top - bottomGap) / MAX_ROWS);

          // Centrer verticalement si < 4 joueurs
          const usedH  = this.players.length * rowH;
          const padTop = top + Math.floor(((MAX_ROWS - this.players.length) * rowH) / 2);



          // en-têtes frame
          ctx.fillStyle='#cbd5e1'; ctx.font='24px system-ui,Segoe UI,Roboto';
          ctx.fillText('Total', left + nameW + 10*cellW + totalW/2 - 24, top - 16);

          // lignes joueurs
          for(let p=0; p<this.players.length; p++){
            const py = padTop + p*rowH;   // centre proprement entre 1 et 3 joueurs

            
            // surlignage de la ligne du joueur
            const rowBgW = nameW + 10*cellW + totalW;
            if (p === this.currP) {
              ctx.fillStyle = 'rgba(34,211,238,0.07)'; // couleur : cyan
              ctx.fillRect(left, py, rowBgW, rowH-24);
            }


            // nom
            ctx.fillStyle='#e5e7eb'; ctx.font='bold 36px system-ui,Segoe UI,Roboto';
            ctx.fillText(this.players[p].name, left, py + 42);

            for (let f = 0; f < 10; f++) {
              const x = left + nameW + f*cellW;
              const cellH = rowH - 24;
              const headerH = 32;                   // barre bleue
              const playTop = py + headerH;
              const playBottom = py + cellH;
              const fr = this.players[p].frames[f];

              // contour
              ctx.strokeStyle = '#334155';
              ctx.lineWidth = 3;
              ctx.strokeRect(x, py, cellW, cellH);

              // barre bleue + numéro
              const grad = ctx.createLinearGradient(x, py, x, py+headerH);
              grad.addColorStop(0,'#1ea0ff');
              grad.addColorStop(1,'#1676d6');
              ctx.fillStyle = grad;
              ctx.fillRect(x, py, cellW, headerH);

              ctx.save();
              ctx.fillStyle='#e6f4ff';
              ctx.font='bold 18px system-ui,Segoe UI,Roboto';
              ctx.textAlign='center';
              ctx.textBaseline='middle';
              ctx.fillText(String(f+1), x + cellW/2, py + headerH/2);
              ctx.restore();

              // ombre sous la barre bleue
              ctx.fillStyle = 'rgba(0,0,0,0.28)';
              ctx.fillRect(x, py + headerH, cellW, 1.5);

              // fond bas
              const pgrad = ctx.createLinearGradient(x, playTop, x, playBottom);
              pgrad.addColorStop(0,'#122b3a');
              pgrad.addColorStop(1,'#0d1f2b');
              ctx.fillStyle = pgrad;
              ctx.fillRect(x+1.5, playTop+1.5, cellW-3, playBottom - playTop - 3);

              // grille
              ctx.lineCap = 'butt';
              ctx.lineJoin = 'miter';
              ctx.miterLimit = 2;

              const midY   = Math.round(playTop + (playBottom - playTop) * 0.55); // ligne médiane
              const inset  = Math.round(cellW * 0.08);                            // marge intérieure
              const baseLeft  = x + inset;
              const baseRight = x + cellW - inset;
              const midX  = x + Math.round(cellW / 2);
              const topCap = playTop + 6;                                         // marge haute sous la barre
              const L = 16;                                                        // longueur petite branche

              ctx.strokeStyle = '#77a9c6';
              ctx.lineWidth = 2;

              // 1) ligne horizontale (de gauche à droite)
              ctx.beginPath();
              ctx.moveTo(baseLeft,  midY);
              ctx.lineTo(baseRight, midY);
              ctx.stroke();

              // 2) le "L" pour séparer lancer 1 / lancer 2 et total
              function drawLUp(xp, dir = +1){
                // verticale (milieu -> haut)
                ctx.beginPath();
                ctx.moveTo(xp, midY);
                ctx.lineTo(xp, topCap);
                ctx.stroke();
                // branche horizontale au milieu
                ctx.beginPath();
                ctx.moveTo(xp, midY);
                ctx.lineTo(xp + dir*L, midY); // dir=+1 → droite, dir=-1 → gauche
                ctx.stroke();
              }

              if (f < 9) {
              // côtés + séparateur central
              drawLUp(baseLeft,  +1);   // gauche → droite
              drawLUp(midX,      +1);   // séparateur → droite
              drawLUp(baseRight, -1);   // droite  ← gauche

              // --- marques (lancer 1 / lancer 2) EN HAUT, CENTRÉES ---
              const r1 = fr.rolls[0], r2 = fr.rolls[1];
              if (r1 != null || r2 != null) {
                const m1 = (r1 === 10) ? 'X' : (r1 == null ? '' : String(r1));
                const m2 = (r1 === 10) ? ''  : (
                  (r1 != null && r2 != null && r1 + r2 === 10) ? '/' :
                  (r2 == null ? '' : String(r2))
                );

                const markY   = py + headerH + 25; // juste sous la barre bleue
                const centerL = (baseLeft + midX) / 2; // centre demi-case gauche
                const centerR = (midX + baseRight) / 2;// centre demi-case droite

                ctx.save();
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 24px system-ui,Segoe UI,Roboto';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(m1, centerL, markY);      // lancer 1
                ctx.fillText(m2, centerR, markY);      // lancer 2
                ctx.restore();
              }
            } else {
              // 10e lancer : 3 sous-zones (donc 2 séparateurs)
              const third = cellW / 3;
              const s1 = x + Math.round(third);
              const s2 = x + Math.round(2 * third);

              // grille "L" (gauche, séparateurs, droite)
              drawLUp(baseLeft,  +1);
              drawLUp(s1,        +1);
              drawLUp(s2,        +1);
              drawLUp(baseRight, -1);

              // --- 10e frame : 3 marques EN HAUT, CENTRÉES dans chaque tiers ---
              const r = fr.rolls;
              const mark = (i)=>{
                if (r[i]==null) return '';
                if (i===0 && r[0]===10) return 'X';
                if (i===1){
                  if (r[0]===10 && r[1]===10) return 'X';
                  if (r[0] < 10 && (r[0] + r[1] === 10)) return '/';
                }
                if (i===2){
                  if (r[0]===10 && r[1]===10 && r[2]===10) return 'X';
                  if ((r[0]===10 && r[1] < 10 && r[1]+r[2]===10) ||
                      (r[0] < 10 && r[0]+r[1]===10 && r[2]!==10)) return '/';
                }
                return String(r[i]);
              };

              const markY   = py + headerH + 25;           // juste sous la barre bleue
              const center1 = (baseLeft + s1) / 2;        // centres des 3 tiers
              const center2 = (s1 + s2) / 2;
              const center3 = (s2 + baseRight) / 2;

              ctx.save();
              ctx.fillStyle = '#e2e8f0';
              ctx.font = 'bold 24px system-ui,Segoe UI,Roboto';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'top';
              ctx.fillText(mark(0), center1, markY);
              ctx.fillText(mark(1), center2, markY);
              ctx.fillText(mark(2), center3, markY);
              ctx.restore();
            }



              //score cumulé en BAS, centré
              const started = fr.rolls && fr.rolls.some(v => v != null);
              if (started && fr.cum != null){
                ctx.save();
                ctx.fillStyle = '#c6e1ff';
                ctx.font = '20px system-ui,Segoe UI,Roboto';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                const cumX = x + cellW / 2;  // centre horizontal de la case
                const cumY = playBottom - 25; // x px au-dessus du bas de la case
                ctx.fillText(String(fr.cum), cumX, cumY);

                ctx.restore();
              }
            }


            // total final
            let tot = null;
            for (let ff = 9; ff >= 0; ff--){
              const fr2 = this.players[p].frames[ff];
              const started2 = fr2.rolls && fr2.rolls.some(v => v != null);
              if (started2 && fr2.cum != null) { tot = fr2.cum; break; }
            }

            const tx  = left + nameW + 10*cellW;
            // nettoie la cellule Total
            ctx.fillStyle = 'rgba(11,17,24,0.92)';
            ctx.fillRect(tx+1, py+1, totalW-2, rowH-26);
            ctx.strokeStyle='#334155'; ctx.lineWidth=3; ctx.strokeRect(tx, py, totalW, rowH-24);
            if (tot != null){
              ctx.fillStyle='#a7f3d0'; ctx.font='bold 32px system-ui,Segoe UI,Roboto';
              ctx.textAlign='center';
              ctx.textBaseline='middle';
              ctx.fillText(String(tot), tx + totalW/2, py + (rowH-24)/2);
            }

          }

          // highlight du joueur en cours
          try{
            const x = left + nameW + this.currF*cellW;
            const y = top + this.currP*rowH;
            ctx.strokeStyle='#22d3ee'; ctx.lineWidth=5;
            ctx.strokeRect(x+2, y+2, cellW-4, rowH-28);
          }catch(e){}

          // push texture
          try{
            const mat = this._mainPlane?.components?.material?.material;
            if (mat && mat.map) mat.map.needsUpdate = true;
            const mesh = this._mainPlane?.getObject3D('mesh');
            if (mesh && mesh.material && mesh.material.map) mesh.material.map.needsUpdate = true;
          }catch(e){}
        },

        // Calcul des scores
        _computeScores(){
          for (const p of this.players){
            // aplanir les lancers
            const rolls = [];
            for (let f=0; f<9; f++){
              const r=p.frames[f].rolls;
              if (r[0]===10) { rolls.push(10); } else { rolls.push(r[0]||0, r[1]||0); }
            }
            // 10e round (0..3 lancers)
            const r10=p.frames[9].rolls; for (const v of r10) if (v!=null) rolls.push(v);

            // score frame par frame
            let i=0, cum=0;
            for (let f=0; f<10; f++){
              let frameScore=null;
              if (f<9){
                if (rolls[i]===10){ // strike
                  frameScore = 10 + (rolls[i+1]??0) + (rolls[i+2]??0);
                  i += 1;
                }else{
                  const a=rolls[i]??0, b=rolls[i+1]??0;
                  if (a+b===10){ // spare
                    frameScore = 10 + (rolls[i+2]??0);
                  }else{
                    frameScore = a+b;
                  }
                  i += 2;
                }
              }else{
                // 10e: somme des lancers présents
                const a=rolls[i]??0, b=rolls[i+1]??0, c=rolls[i+2]??0;
                frameScore = a + (rolls[i+1]!=null?b:0) + (rolls[i+2]!=null?c:0);
              }
              cum = (frameScore!=null)? (cum + frameScore) : cum;
              p.frames[f].score = frameScore;
              p.frames[f].cum   = cum;
            }
          }
          this._renderMainBoard();
        },

        // Enregistrer un lancer terminé (nombre de quilles tombées)
        _registerThrow(pins){
          const P=this.players[this.currP], F=P.frames[this.currF];
          // bornes en cas d’artefact
          if (pins<0) pins=0;
          if (this.currF<9){
            if (this.currRoll===0){
              F.rolls[0]=pins;
              if (pins===10){ // STRIKE
                this._advanceTurn(true); // fin de frame
              }else{
                this.currRoll=1; // 2e lancer à venir
              }
            }else{
              F.rolls[1]=pins;
              this._advanceTurn(true); // fin de frame
            }
          }else{
            // 10e frame
            if (this.currRoll===0){
              F.rolls[0]=pins; this.currRoll=1;
            }else if (this.currRoll===1){
              F.rolls[1]=pins;
              if ( (F.rolls[0]===10) || ((F.rolls[0]||0)+(F.rolls[1]||0)===10) ){
                this.currRoll=2; // balle bonus
              }else{
                this._advanceTurn(true);
              }
            }else{
              F.rolls[2]=pins;
              this._advanceTurn(true);
            }
          }
          this._computeScores();
        },

        // Avancer au prochain joueur / frame, puis redessiner
        _advanceTurn(resetPins){
          // joueur suivant
          if (this.currP < this.players.length-1){ this.currP++; }
          else { this.currP=0; if (this.currF<9) this.currF++; }
          this.currRoll=0;
          // reset visuel si demandé (la physique fait déjà un reset après strike/2e lancer)
          this._renderMainBoard();
        },






      // -------- Construction de la piste --------
      _buildLane(){
        const scene = this.el.sceneEl;

        // Sol
        const ground = document.createElement('a-plane');
        ground.setAttribute('position','0 -.2 2.5');
        ground.setAttribute('rotation','-90 0 0');
        ground.setAttribute('width', 40);
        ground.setAttribute('height', 5);
        ground.setAttribute('color', '#2a2f38');
        ground.setAttribute('material', 'visible: false');
        ground.setAttribute('static-body','');
        ground.setAttribute('shadow','receive:true');
        scene.appendChild(ground);

        // Boundaries (invisibles)
        const bounds = [
          document.createElement('a-box'), // arrière
          document.createElement('a-box'), // avant-droit
          document.createElement('a-box'), // avant-gauche
          document.createElement('a-box'), // gauche
          document.createElement('a-box'), // droite
          document.createElement('a-box'), // dessous
          document.createElement('a-box'), // dessus
          document.createElement('a-box'), // sol
          document.createElement('a-box')  // face
        ]
        bounds[0].setAttribute('position', `0 5 5`);
        bounds[0].setAttribute('width', 40);
        bounds[0].setAttribute('height', 10);
        bounds[0].setAttribute('depth', .85);
        bounds[1].setAttribute('position', `11 -.5 -19`);
        bounds[1].setAttribute('width', 19);
        bounds[1].setAttribute('height', 1);
        bounds[1].setAttribute('depth', 38);
        bounds[2].setAttribute('position', `-11 -.5 -19`);
        bounds[2].setAttribute('width', 19);
        bounds[2].setAttribute('height', 1);
        bounds[2].setAttribute('depth', 38);
        bounds[3].setAttribute('position', `19 5 -15.5`);
        bounds[3].setAttribute('rotation', '0 90 0');
        bounds[3].setAttribute('width', 50);
        bounds[3].setAttribute('height', 10);
        bounds[3].setAttribute('depth', 1);
        bounds[4].setAttribute('position', `-19 5 -15.5`);
        bounds[4].setAttribute('rotation', '0 90 0');
        bounds[4].setAttribute('width', 50);
        bounds[4].setAttribute('height', 10);
        bounds[4].setAttribute('depth', 1);
        bounds[5].setAttribute('position', `0 -.6 -19.5`);
        bounds[5].setAttribute('rotation', '90 0 0');
        bounds[5].setAttribute('width', 40);
        bounds[5].setAttribute('height', 50);
        bounds[5].setAttribute('depth', 1);
        bounds[6].setAttribute('position', `0 9.2 -11.5`);
        bounds[6].setAttribute('rotation', '88 0 0');
        bounds[6].setAttribute('width', 40);
        bounds[6].setAttribute('height', 50);
        bounds[6].setAttribute('depth', 1);
        bounds[7].setAttribute('position', `0 -.5 2.5`);
        bounds[7].setAttribute('rotation', '90 0 0');
        bounds[7].setAttribute('width', 40);
        bounds[7].setAttribute('height', 5);
        bounds[7].setAttribute('depth', 1);
        bounds[8].setAttribute('position', `0 4.5 -36.8`);
        bounds[8].setAttribute('rotation', '-10 0 0');
        bounds[8].setAttribute('width', 40);
        bounds[8].setAttribute('height', 7);
        bounds[8].setAttribute('depth', 1);
        bounds.forEach(b=>{
          b.setAttribute('material', 'visible: false');
          b.setAttribute('static-body','');
          scene.appendChild(b);
        });
        this._lane_1 = document.createElement('a-box');
        this._lane_1.setAttribute('position', `-16.7 -0.02 ${-this.data.laneLength/2}`);
        this._lane_1.setAttribute('width', this.data.laneWidth);
        this._lane_1.setAttribute('height', 0.04);
        this._lane_1.setAttribute('depth', this.data.laneLength);
        this._lane_1.setAttribute('material', 'visible:false');
        this._lane_1.setAttribute('static-body','');
        this._lane_1.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_1);
        this._lane_2 = document.createElement('a-box');
        this._lane_2.setAttribute('position', `-13.45 -0.02 ${-this.data.laneLength/2}`);
        this._lane_2.setAttribute('width', this.data.laneWidth);
        this._lane_2.setAttribute('height', 0.04);
        this._lane_2.setAttribute('depth', this.data.laneLength);
        this._lane_2.setAttribute('material', 'visible:false');
        this._lane_2.setAttribute('static-body','');
        this._lane_2.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_2);
        this._lane_3 = document.createElement('a-box');
        this._lane_3.setAttribute('position', `-9.95 -0.02 ${-this.data.laneLength/2}`);
        this._lane_3.setAttribute('width', this.data.laneWidth);
        this._lane_3.setAttribute('height', 0.04);
        this._lane_3.setAttribute('depth', this.data.laneLength);
        this._lane_3.setAttribute('material', 'visible:false');
        this._lane_3.setAttribute('static-body','');
        this._lane_3.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_3);
        this._lane_4 = document.createElement('a-box');
        this._lane_4.setAttribute('position', `-6.75 -0.02 ${-this.data.laneLength/2}`);
        this._lane_4.setAttribute('width', this.data.laneWidth);
        this._lane_4.setAttribute('height', 0.04);
        this._lane_4.setAttribute('depth', this.data.laneLength);
        this._lane_4.setAttribute('material', 'visible:false');
        this._lane_4.setAttribute('static-body','');
        this._lane_4.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_4);
        this._lane_5 = document.createElement('a-box');
        this._lane_5.setAttribute('position', `-3.23 -0.02 ${-this.data.laneLength/2}`);
        this._lane_5.setAttribute('width', this.data.laneWidth);
        this._lane_5.setAttribute('height', 0.04);
        this._lane_5.setAttribute('depth', this.data.laneLength);
        this._lane_5.setAttribute('material', 'visible:false');
        this._lane_5.setAttribute('static-body','');
        this._lane_5.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_5);
        this._lane_6 = document.createElement('a-box');
        this._lane_6.setAttribute('position', `3.5 -0.02 ${-this.data.laneLength/2}`);
        this._lane_6.setAttribute('width', this.data.laneWidth);
        this._lane_6.setAttribute('height', 0.04);
        this._lane_6.setAttribute('depth', this.data.laneLength);
        this._lane_6.setAttribute('material', 'visible:false');
        this._lane_6.setAttribute('static-body','');
        this._lane_6.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_6);
        this._lane_7 = document.createElement('a-box');
        this._lane_7.setAttribute('position', `6.75 -0.02 ${-this.data.laneLength/2}`);
        this._lane_7.setAttribute('width', this.data.laneWidth);
        this._lane_7.setAttribute('height', 0.04);
        this._lane_7.setAttribute('depth', this.data.laneLength);
        this._lane_7.setAttribute('material', 'visible:false');
        this._lane_7.setAttribute('static-body','');
        this._lane_7.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_7);
        this._lane_8 = document.createElement('a-box');
        this._lane_8.setAttribute('position', `10.25 -0.02 ${-this.data.laneLength/2}`);
        this._lane_8.setAttribute('width', this.data.laneWidth);
        this._lane_8.setAttribute('height', 0.04);
        this._lane_8.setAttribute('depth', this.data.laneLength);
        this._lane_8.setAttribute('material', 'visible:false');
        this._lane_8.setAttribute('static-body','');
        this._lane_8.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_8);
        this._lane_9 = document.createElement('a-box');
        this._lane_9.setAttribute('position', `13.45 -0.02 ${-this.data.laneLength/2}`);
        this._lane_9.setAttribute('width', this.data.laneWidth);
        this._lane_9.setAttribute('height', 0.04);
        this._lane_9.setAttribute('depth', this.data.laneLength);
        this._lane_9.setAttribute('material', 'visible:false');
        this._lane_9.setAttribute('static-body','');
        this._lane_9.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_9);
        this._lane_10 = document.createElement('a-box');
        this._lane_10.setAttribute('position', `16.95 -0.02 ${-this.data.laneLength/2}`);
        this._lane_10.setAttribute('width', this.data.laneWidth);
        this._lane_10.setAttribute('height', 0.04);
        this._lane_10.setAttribute('depth', this.data.laneLength);
        this._lane_10.setAttribute('material', 'visible:false');
        this._lane_10.setAttribute('static-body','');
        this._lane_10.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane_10);

        // Piste
        this._lane = document.createElement('a-box');
        this._lane.setAttribute('position', `0 -0.02 ${-this.data.laneLength/2}`);
        this._lane.setAttribute('width', this.data.laneWidth);
        this._lane.setAttribute('height', 0.04);
        this._lane.setAttribute('depth', this.data.laneLength);
        this._lane.setAttribute('color', '#886544');
        this._lane.setAttribute('material', 'roughness:0.6; metalness:0.0; visible:false');
        this._lane.setAttribute('static-body','');
        this._lane.setAttribute('shadow','receive:true; cast:false');
        scene.appendChild(this._lane);

        // Murs/gouttières
        this._leftWall  = document.createElement('a-box');
        this._rightWall = document.createElement('a-box');
        [this._leftWall,this._rightWall].forEach((w,idx)=>{
          const side = idx?1:-1;
          w.setAttribute('position', `${side*(this.data.laneWidth/2+0.4)} 0.2 ${-this.data.laneLength/2}`);
          w.setAttribute('width', 0.2); w.setAttribute('height', 0.4); w.setAttribute('depth', this.data.laneLength);
          w.setAttribute('material', 'opacity: 0.2; emissive:#a5eff7');
          w.setAttribute('color','#a5eff7'); w.setAttribute('static-body','');
          scene.appendChild(w);
        });

        // Rack (pose-boules)
        const rack = document.createElement('a-box');
        rack.setAttribute('position', `1.753 .27 2.45`);
        rack.setAttribute('width', 0.44);
        rack.setAttribute('height', 0.55);
        rack.setAttribute('depth', 2.5);
        rack.setAttribute('material', 'visible:false');
        rack.setAttribute('color', '#4b5563');
        rack.setAttribute('static-body','');
        rack.setAttribute('shadow','receive:true');
        scene.appendChild(rack);
        const rack2 = document.createElement('a-box');
        rack2.setAttribute('position', `1.753 .55 .68`);
        rack2.setAttribute('width', 0.68);
        rack2.setAttribute('height', 1.1);
        rack2.setAttribute('depth', 1);
        rack2.setAttribute('material', 'visible:false');
        rack2.setAttribute('color', '#4b5563');
        rack2.setAttribute('static-body','');
        rack2.setAttribute('shadow','receive:true');
        scene.appendChild(rack2);

        // Ligne de faute
        const foul = document.createElement('a-box');
        foul.setAttribute('position', `0 0.041 ${this.data.foulZ}`);
        foul.setAttribute('width', this.data.laneWidth);
        foul.setAttribute('height', 0.005);
        foul.setAttribute('depth', 0.02);
        foul.setAttribute('material', 'visible:false');
        foul.setAttribute('color', '#ef4444');
        foul.setAttribute('static-body','');
        scene.appendChild(foul);

        this._applyDifficulty();
      },
      _applyDifficulty(){
        const d = DIFFS[this.data.difficulty] || DIFFS.normal;
        const half = d.gutterHalf;
        this._leftWall.setAttribute('position',  `${-(half+0.1)} 0.2 ${-this.data.laneLength/2}`);
        this._rightWall.setAttribute('position', `${+(half+0.1)} 0.2 ${-this.data.laneLength/2}`);
        this._ballDamp = {lin: d.ballDampLin, ang: d.ballDampAng, wobble: d.wobble};
        this._setStatus(`Difficulte: ${this.data.difficulty}`);
      },

      // -------- Pins & Boule --------
      spawnPins(){
        this._pins.forEach(p=>p.remove()); this._pins.length=0;
        const base = new THREE.Vector3(0, 0.38, this.data.pinZ);
        const dx = 0.6, dz = -0.525; // espacements
        const rows = [
          [{x:0,        z:0}],
          [{x:-dx/2,   z:dz},       {x:+dx/2, z:dz}],
          [{x:-dx,     z:dz*2},     {x:0, z:dz*2},     {x:+dx, z:dz*2}],
          [{x:-dx*1.5, z:dz*3},     {x:-dx*0.5,z:dz*3},{x:+dx*0.5,z:dz*3},{x:+dx*1.5,z:dz*3}]
        ];
        rows.flat().forEach((o)=>{
          const pin = document.createElement('a-entity');
          const pModel = document.createElement('a-entity');
          
          // Géométrie + physique sur le parent (invisible)
          pin.setAttribute('geometry', 'primitive: cylinder; radius: 0.13; height: 0.75');
          pin.setAttribute('material', 'transparent: true; opacity: 0');
          pin.setAttribute('dynamic-body', 'mass:1.5; shape:cylinder; linearDamping:0.01; angularDamping:0.01');

          // Compat: on conserve un attribut radius pour le code qui lit ent.getAttribute('radius')
          pin.setAttribute('radius', 0.12);

          pin.setAttribute('class','pin grab-target');
          pin.setAttribute('position', `${base.x+o.x} ${base.y} ${base.z+o.z}`);

          pin.addEventListener('collide', (e)=>{
            const other = e.detail && e.detail.body && e.detail.body.el;
            if (!other) return;
            const v = other.body ? (other.body.velocity.length()||0) : 0;
            if (v > 0.8){
              const wp = pin.object3D.getWorldPosition(new THREE.Vector3());
              playAt(this.el.sceneEl,'sndPin',wp);
            }
          });

          // Enfant visuel : le modèle glTF uniquement (affiché)
          pModel.setAttribute('gltf-model', `Assets/3dModels/Pin.glb`);
          pModel.setAttribute('position', '0 -.37 0');
          pModel.setAttribute('scale', '2 2 2');
          pModel.setAttribute('shadow','cast:true; receive:true');

          pin.appendChild(pModel);
          this.el.sceneEl.appendChild(pin);

          pin.dataset.pinIndex = String(this._pins.length + 1);
          this._pins.push(pin);
        });
      },
      spawnBall(ballIndex=1, announce=false){
        if (this._ball && this._ball.isConnected) this._ball.remove();
        const spec = BALLS[Math.max(0,Math.min(BALLS.length-1,ballIndex))];
        const b = document.createElement('a-sphere');
        b.setAttribute('class','ball grab-target');
        b.setAttribute('radius', spec.radius);
        // b.setAttribute('color', spec.color);
        b.setAttribute('material', `src: url(Assets/Textures/bwg_Ball_${spec.color}.png); roughness:0.35; metalness:0.1`
                                  /*'shader: overlay-double;' +
                                  'baseColor: #999;' +
                                  'overlay1: #img1;' +
                                  'overlay2: #img2;' +
                                  'overlay1Opacity: 0.8;' +
                                  'overlay2Opacity: 1.0;' +
                                  'overlay2Rotation: 0;' +
                                  'overlay2Scale: 1 1;' +
                                  'transparent: true'*/
        );
        b.setAttribute('position','1.753 1 1.5'); // sur le rack
        b.setAttribute('shadow','cast:true; receive:true');
        b.setAttribute('dynamic-body',`mass:${spec.mass}; shape:sphere; linearDamping:${this._ballDamp.lin}; angularDamping:${this._ballDamp.ang}`);
        this.el.sceneEl.appendChild(b);
        this._ball=b;

        // léger wobble quand on attrape (via petite vitesse angulaire)
        const wob = (this._ballDamp && this._ballDamp.wobble) || 0;
        b.addEventListener('componentinitialized', (ev)=>{
          if (ev.detail && ev.detail.name==='constraint' && wob>0 && b.body){
            b.body.angularVelocity.set( (Math.random()-0.5)*wob, 0, (Math.random()-0.5)*wob );
          }
        });

        if (announce) this._toast(`Boule "${spec.name}" disponible`);
      },

      // Cycle d’un frame (2 lancers)
      resetFrame(hard=false){
        this.throws=0; this.scoreThisFrame=0; this.downSet.clear(); this.inPlay=false;
        if (hard){ this._toast('Réinitialisation complète.'); }
        this.spawnPins();
        this.spawnBall(1);
        this._setStatus(`Difficulte: ${this.data.difficulty} — Mode entraînement (1 frame)`);
        this._setScore();
      },

      tick(t,dt){
        // détecte quille tombée par inclinaison (dot<0.75)
        const THRESH = 0.75;
        this._pins.forEach(pin=>{
          if (this.downSet.has(pin)) return;
          const up = new THREE.Vector3(0,1,0).applyQuaternion(pin.object3D.quaternion);
          const dot = up.dot(new THREE.Vector3(0,1,0));
          if (dot < THRESH || pin.object3D.position.y < 0.05){
            this.downSet.add(pin);
          }
        });
        if (this._lastDownCount !== this.downSet.size){
          this._lastDownCount = this.downSet.size;
          this._renderScoreboard();
}


        if (this._ball && this._ball.body){
          const v = this._ball.body.velocity.length();
          const z = this._ball.object3D.position.z;
          const held = this._ball.hasAttribute('constraint'); // tenue en main
          if (!this.inPlay){
            // passe en jeu si franchit la ligne de faute avec vitesse
            if (!held && z < this.data.foulZ - 0.05 && v > 0.2){
              this.inPlay = true;
              this._startDownCount = this.downSet.size;
              this.throws += 1;
              this._setScore();
            }
          }else{
            // fin du lancer si arrêt ou sortie
            if (v < 0.05 || z < -this.data.laneLength){
              this._finishThrow();
            }
          }
        }
      },



      _finishThrow(){
        if (!this.inPlay) return;
        this.inPlay=false;
        const fallenNow = this.downSet.size;
        const knocked   = Math.max(0, fallenNow - (this._startDownCount || 0));

        // -> enregistre ce lancer dans le tableau des scores
        this._registerThrow(knocked);

        this.scoreThisFrame = fallenNow;

        if (this.throws===1 && fallenNow===10){
          this._setStatus('🎯 STRIKE ! Réinitialisation...');
          playAt(this.el.sceneEl,'sndStrike', new THREE.Vector3(0,1.6,-10));
          setTimeout(()=> this.resetFrame(), 1200);
          return;
        }

        if (this.throws===2){
          if (fallenNow===10){
            this._setStatus('✨ SPARE ! Réinitialisation...');
            playAt(this.el.sceneEl,'sndStrike', new THREE.Vector3(0,1.6,-10));
          }else{
            this._setStatus('Fin du frame. Réinitialisation...');
            playAt(this.el.sceneEl,'sndEnd', new THREE.Vector3(0,1.6,-10));
          }
          setTimeout(()=> this.resetFrame(), 1200);
        }else{
          this._setStatus('Deuxième lancer — visez les quilles restantes');
          this.spawnBall(1);
        }
        this._setScore();
      }
    });

    // Bouton VR : envoie une action quand on clique au laser
    AFRAME.registerComponent('vrbtn', {
  schema: { action:{default:''}, value:{default:''} },
  init(){
    const BASE  = 'color:#1f2937; opacity:0.92; transparent:true; depthTest:false';
    const HOVER = 'color:#0ea5e9;  opacity:0.95; transparent:true; depthTest:false';

    const hoverIn  = () => this.el.setAttribute('material', HOVER);
    const hoverOut = () => this.el.setAttribute('material', BASE);

    this.onClick = () => {
      const game = this.el.sceneEl.components['bowling-game']; if(!game) return;
      const v = this.data.value;
      switch (this.data.action) {
        case 'diff':    game.data.difficulty = v; game._applyDifficulty(); game._toast(`Difficulte: ${v}`); break;
        case 'ball':    game.spawnBall(parseInt(v,10), true); break;
        case 'players': game._initMatch(game._defaultNames(parseInt(v,10))); game.resetFrame(true); break;
        case 'reset':   game.resetFrame(true); break;
      }
    };

    this.el.classList.add('ui-hit');
    // matériau de base
    this.el.setAttribute('material', BASE);

    this.el.addEventListener('mouseenter', hoverIn);
    this.el.addEventListener('mouseleave', hoverOut);
    this.el.addEventListener('click', this.onClick);
  },
  remove(){ this.el.removeEventListener('click', this.onClick); }
});






// ---- UI: fond auto qui s'ajuste au contenu ----
AFRAME.registerComponent('ui-autobg', {
  schema:{
    target: {type:'selector', default:''}, // contenu à mesurer
    padding:{default:'0.20 0.16'}, // marges (x y) autour du contenu
    color:  {default:'#0b1118'},
    opacity:{default:0.92},
    z:      {default:-0.01}, // fond derrière
    side:   {default:'double'},
    offsetX: {default:0}, // décalage (gauche-droite)
    offsetY: {default:0} // décalage local du fond (haut-bas)
  },
  init(){
    // crée le fond (plane) comme 1er enfant
    this.bg = document.createElement('a-plane');
    this.bg.setAttribute('material', `color:${this.data.color}; opacity:${this.data.opacity}; transparent:true; side:${this.data.side}; depthTest:true`);
    this.el.insertBefore(this.bg, this.el.firstChild);

    this._refresh = this._refresh.bind(this);

    // re-mesure quand le contenu bouge ou change
    this.el.addEventListener('child-attached', this._refresh);
    this.el.addEventListener('child-detached', this._refresh);
    this.el.addEventListener('componentchanged', ev=>{
      if (ev.detail && ev.detail.name==='text') this._refresh();
    });

    // premier calage (+ recalcule 2–3 fois pour attendre les géométries de texte)
    setTimeout(this._refresh, 0);
    setTimeout(this._refresh, 60);
    setTimeout(this._refresh, 180);
  },
  remove(){
    this.el.removeEventListener('child-attached', this._refresh);
    this.el.removeEventListener('child-detached', this._refresh);
  },
  _refresh(){
    const root = this.data.target || this.el;
    if (!root || !root.object3D) return;

    root.object3D.updateMatrixWorld(true);
    const box = new THREE.Box3().makeEmpty();
    const tmp = new THREE.Box3();

    // union des bounding boxes de tous les Mesh du contenu (hors bg)
    root.object3D.traverse(o=>{
      if (!o.visible || !o.isMesh) return;
      if (o.el && o.el === this.bg) return;
      const geo = o.geometry; if (!geo) return;
      if (!geo.boundingBox) geo.computeBoundingBox();
      tmp.copy(geo.boundingBox).applyMatrix4(o.matrixWorld);
      box.union(tmp);
    });

    if (box.isEmpty()) return;

    // taille/centre en LOCAL du conteneur
    const sizeW = new THREE.Vector3(); box.getSize(sizeW);
    const centerW = new THREE.Vector3(); box.getCenter(centerW);

    const inv = new THREE.Matrix4().copy(this.el.object3D.matrixWorld).invert();
    centerW.applyMatrix4(inv);

    const ws = new THREE.Vector3(); this.el.object3D.getWorldScale(ws);
    const w = sizeW.x / (ws.x||1);
    const h = sizeW.y / (ws.y||1);

    const pad = this.data.padding.trim().split(/\s+/).map(parseFloat);
    const padX = pad[0] ?? 0.2, padY = pad[1] ?? pad[0] ?? 0.16;

    this.bg.setAttribute('width',  (w + padX*2).toFixed(3));
    this.bg.setAttribute('height', (h + padY*2).toFixed(3));

    centerW.x += this.data.offsetX;
    centerW.y += this.data.offsetY;

    this.bg.setAttribute('position', `${centerW.x.toFixed(3)} ${centerW.y.toFixed(3)} ${this.data.z}`);
  }
});



  </script>
</head>
<body>
  <div class="hud">
    <strong>Commandes VR</strong><br/>
    • Stick gauche: se déplacer &nbsp;• Stick droit: rotation<br/>
    • <b>Grip</b> saisir/lâcher • <b>Trigger</b> (non utilisé ici)<br/>
    <u>Clavier</u> : ZQSD pour déplacer la caméra (desktop), souris pour regarder<br/>
    <div id="status" style="margin-top:6px;opacity:.85"></div>
    <div id="score" style="margin-top:2px"></div>
  </div>

  <div class="panel" role="group" aria-label="Paramètres Bowling">
    <h3>VR Bowling — Réglages</h3>
    <div style="margin-bottom:6px">Difficulte :</div>
    <div class="row" style="margin-bottom:10px">
      <div class="chip" data-diff="easy">Facile</div>
      <div class="chip" data-diff="normal">Normal</div>
      <div class="chip" data-diff="hard">Difficile</div>
    </div>
    <div style="margin-bottom:6px">Boules :</div>
    <div class="row" style="margin-bottom:10px">
      <button data-ball="0">Legere</button>
      <button data-ball="1">Standard</button>
      <button data-ball="2">Lourde</button>
      <button id="resetAll" style="margin-left:auto;background:#374151">Réinit. piste</button>
    </div>

    <div style="margin-top:6px;margin-bottom:6px">Joueurs :</div>
    <div class="row" id="playersPicker" style="margin-bottom:10px">
      <div class="chip playerCount" data-players="1">1</div>
      <div class="chip playerCount" data-players="2">2</div>
      <div class="chip playerCount" data-players="3">3</div>
      <div class="chip playerCount" data-players="4">4</div>
    </div>

    <small style="opacity:.8">Mode entraînement : 1 frame, jusqu’à 2 lancers. Strike ⇒ reset immédiat.</small>
  </div>

  <div id="toast" class="toast" role="status"></div>

  <a-scene
    background="color:#0f141a"
    renderer="colorManagement:true;physicallyCorrectLights:true;antialias:true;sortTransparentObjects:true"
    shadow="type:pcfsoft"
    physics="gravity:-9.8;debug:true"
    bowling-game="difficulty: normal"
  >
    <a-assets>
      <!-- sons placeholders -->
      <audio id="sndThrow"  src=""></audio>
      <audio id="sndPin"    src="Assets\Sounds\Bowling\Sample_0013.wav"></audio>
      <audio id="sndStrike" src="Assets\Sounds\Voices\CrowdSlowClap.wav"></audio>
      <audio id="sndEnd"    src="Assets\Sounds\Bowling\Sample_0031.wav"></audio>
      <audio id="sndLoop"   src="Assets\Sounds\Musics\39 Bowling (Training).mp3"></audio>
      <canvas id="scoreCanvas" width="1024" height="512"></canvas>
      <canvas id="scoreMain" width="2048" height="1024"></canvas>

      <a-asset-item id="pinGLB" src="Bowling pins.glb"></a-asset-item> <!-- quilles, modèle pas fonctionnel pour le moment -->
    </a-assets>

    <!-- Pistes de bowling -->
    <a-entity gltf-model="Assets/3dModels/BowlingField.glb" rotation="0 -90 0" shadow="receive: true; cast: false" static-body="" scale="2 2 2"></a-entity>

    <!-- Lumières -->
    <a-entity light="type:ambient; intensity:1; color:#ffffff"></a-entity>
    <a-entity light="type:directional; intensity:1.2;  castShadow:true" position="2 6 3" rotation="-45 30 0" material="alphaHash: true"></a-entity>

    <!-- RIG + Caméra  -->
    <a-entity id="rig" position="0 1.6 2.8">
      <a-entity id="cam" camera look-controls wasd-controls="acceleration:20"></a-entity>



      <!-- Main gauche -->
      <a-entity id="leftCtl"
        oculus-touch-controls="hand: left"
        left-stick-move="rig:#rig; speed:2.0; dead:0.18"
        laser-controls="hand: left"
        raycaster="objects:.grab-target:not(.held), .ui-hit; showLine:true; far:6; interval:0"
        cursor="rayOrigin: entity; fuse: false"
        static-body="shape: sphere; sphereRadius: 0.04"
        ray-grab>
      </a-entity>

      <!-- Main droite -->
      <a-entity id="rightCtl"
        oculus-touch-controls="hand: right"
        right-stick-smoothturn="rig:#rig; speedDeg:140; dead:0.18"
        laser-controls="hand: right"
        raycaster="objects:.grab-target:not(.held), .ui-hit; showLine:true; far:6; interval:0"
        cursor="rayOrigin: entity; fuse: false"
        static-body="shape: sphere; sphereRadius: 0.04"
        ray-grab>
      </a-entity>
    </a-entity>


    <!-- Structure plafond + écrans -->
  <a-entity id="overheadRig" position="0 5.6 -3.0" rotation="0 0 0">
    <!-- Barre -->
    <a-box position="0 0 -0.2" width="6.2" height="0.08" depth="0.12" color="#1c2430"></a-box>

    <!-- Tiges -->
    <a-box position="-2.9 -0.45 -0.2" width="0.06" height="0.90" depth="0.06" color="#1c2430"></a-box>
    <a-box position=" 2.9 -0.45 -0.2" width="0.06" height="0.90" depth="0.06" color="#1c2430"></a-box>

    <!-- Écran gauche -->
  <a-entity position="-3.2 -2.60 0" rotation="8 3 0" scale="1.5 1.5 .7">
    <a-plane id="mainBoardPlane"
            width="3" height="1.5"
            material="shader:flat; src:#scoreMain; side:double; transparent:true"></a-plane>
    <a-box position="0 -0.90 0" width="3.3" height="0.06" depth="0.05" color="#0b1118"></a-box>
  </a-entity>

  <!-- Écran droit -->
  <a-entity position=" 3.2 -2.60 0" rotation="8 -3 0" scale="1.5 1.5 .7">
    <a-plane id="scoreboardPlane"
            width="3" height="1.5"
            material="shader:flat; src:#scoreCanvas; side:double; transparent:true"></a-plane>
    <a-box position="0 -0.90 0" width="3.3" height="0.06" depth="0.05" color="#0b1118"></a-box>
  </a-entity>
</a-entity>





        <!-- Panneau de réglages VR -->
        <a-entity id="vrMenu" position="-2.75 1.05 -1.05" rotation="0 35 0" scale="1 1 .5"
                    ui-autobg="target:#vrMenuContent; padding:0.8 0.4; opacity:0.92; z:-0.01; offsetX:-0.45; offsetY:0.1">

          <a-entity id="vrMenuContent">
            <!-- Titre -->
            <a-entity position="-0.20 0.60 0.03"
                      text="value:Reglages :; color:#9bdcff; width:3.6; align:left; zOffset:0.02"></a-entity>

            <!-- Libellés + boutons-->
            <a-entity position="-0.20 0.36 0.03"
                      text="value:Difficulte :; color:#cbd5e1; width:2.6; align:left; zOffset:0.02"></a-entity>

            <a-plane position="-0.60 0.36 0.02" width="0.38" height="0.12" vrbtn="action:diff; value:easy"></a-plane>
            <a-entity position="-0.60 0.36 0.03" text="value:Facile; align:center; width:2; zOffset:0.02"></a-entity>

            <a-plane position="0.00 0.36 0.02" width="0.42" height="0.12" vrbtn="action:diff; value:normal"></a-plane>
            <a-entity position="0.00 0.36 0.03" text="value:Normal; align:center; width:2; zOffset:0.02"></a-entity>

            <a-plane position="0.66 0.36 0.02" width="0.48" height="0.12" vrbtn="action:diff; value:hard"></a-plane>
            <a-entity position="0.66 0.36 0.03" text="value:Difficile; align:center; width:2; zOffset:0.02"></a-entity>

            <a-entity position="-0.20 0.04 0.03"
                      text="value:Boules :; color:#cbd5e1; width:2.6; align:left; zOffset:0.02"></a-entity>

            <a-plane position="-0.80 0.04 0.02" width="0.42" height="0.12" vrbtn="action:ball; value:0"></a-plane>
            <a-entity position="-0.80 0.04 0.03" text="value:Legere; align:center; width:2; zOffset:0.02"></a-entity>

            <a-plane position="0.00 0.04 0.02" width="0.54" height="0.12" vrbtn="action:ball; value:1"></a-plane>
            <a-entity position="0.00 0.04 0.03" text="value:Standard; align:center; width:2.2; zOffset:0.02"></a-entity>

            <a-plane position="0.86 0.04 0.02" width="0.50" height="0.12" vrbtn="action:ball; value:2"></a-plane>
            <a-entity position="0.86 0.04 0.03" text="value:Lourde; align:center; width:2; zOffset:0.02"></a-entity>

            <a-entity position="-0.20 -0.30 0.03"
                      text="value:Joueurs :; color:#cbd5e1; width:2.6; align:left; zOffset:0.02"></a-entity>

            <a-plane position="-0.60 -0.30 0.02" width="0.22" height="0.12" vrbtn="action:players; value:1"></a-plane>
            <a-entity position="-0.60 -0.30 0.03" text="value:1; align:center; width:1.2; zOffset:0.02"></a-entity>

            <a-plane position="-0.20 -0.30 0.02" width="0.22" height="0.12" vrbtn="action:players; value:2"></a-plane>
            <a-entity position="-0.20 -0.30 0.03" text="value:2; align:center; width:1.2; zOffset:0.02"></a-entity>

            <a-plane position="0.20 -0.30 0.02" width="0.22" height="0.12" vrbtn="action:players; value:3"></a-plane>
            <a-entity position="0.20 -0.30 0.03" text="value:3; align:center; width:1.2; zOffset:0.02"></a-entity>

            <a-plane position="0.60 -0.30 0.02" width="0.22" height="0.12" vrbtn="action:players; value:4"></a-plane>
            <a-entity position="0.60 -0.30 0.03" text="value:4; align:center; width:1.2; zOffset:0.02"></a-entity>
      </a-entity>
  </a-entity>


    <!-- Fond map : Ciel -->
    <a-sky color="#ffffff"></a-sky>
  </a-scene>
</body>
</html>
